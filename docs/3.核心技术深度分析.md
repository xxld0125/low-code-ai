# 低代码平台核心技术深度分析

## 一、可视化编辑器技术

### 1.1 画布引擎架构

#### 技术方案对比

| 方案            | 优势                       | 劣势                   | 适用场景           | 代表项目             |
| --------------- | -------------------------- | ---------------------- | ------------------ | -------------------- |
| **DOM 方案**    | 性能好、样式完整、SEO 友好 | 拖拽性能在复杂场景下降 | 页面搭建、表单设计 | 阿里低代码引擎、amis |
| **Canvas 方案** | 渲染性能强、动画流畅       | 交互复杂、无法选中文本 | 图形编辑、游戏编辑 | Figma、Photopea      |
| **SVG 方案**    | 矢量可缩放、适合图表       | 复杂场景性能差         | 流程图、架构图     | draw.io、ProcessOn   |
| **混合方案**    | 结合各方案优点             | 实现复杂度高           | 复杂应用场景       | Canva、Framer        |

#### 主流低代码平台选择

**DOM 方案（推荐）**

- **原因**: 低代码平台主要搭建的是业务页面，需要完整的 CSS 支持、事件处理、无障碍访问等
- **实现**: 通过绝对定位 + transform 实现拖拽，通过 iframe 隔离画布环境
- **性能优化**: 虚拟滚动、组件懒加载、增量渲染

### 1.2 拖拽系统设计

#### 核心能力

1. **拖拽识别**
   - 组件库拖入画布（创建）
   - 画布内组件移动（调整布局）
   - 组件嵌套（容器组件）

2. **布局算法**
   - **自由布局**: 绝对定位，任意放置
   - **流式布局**: Flexbox，自动排列
   - **网格布局**: Grid 系统，对齐辅助
   - **混合布局**: 不同容器支持不同布局方式

3. **辅助功能**
   - **参考线**: 对齐辅助线
   - **吸附**: 自动对齐到网格或其他组件
   - **距离标注**: 显示组件间距
   - **智能排列**: 自动避让、智能插入

#### 技术实现方案

**方案一：原生 HTML5 Drag & Drop API**

```javascript
// 优势：浏览器原生支持
// 劣势：API 不友好、跨浏览器兼容性差、移动端不支持

element.addEventListener('dragstart', e => {
  e.dataTransfer.effectAllowed = 'move'
  e.dataTransfer.setData('text/plain', componentId)
})

dropZone.addEventListener('drop', e => {
  e.preventDefault()
  const componentId = e.dataTransfer.getData('text/plain')
  // 插入组件到画布
})
```

**方案二：基于 Pointer Events（推荐）**

```javascript
// 优势：统一处理鼠标和触摸事件、灵活性强
// 劣势：需要自己处理所有逻辑

element.addEventListener('pointerdown', e => {
  const startX = e.clientX
  const startY = e.clientY

  const onMove = e => {
    const deltaX = e.clientX - startX
    const deltaY = e.clientY - startY
    // 更新组件位置
  }

  const onUp = () => {
    document.removeEventListener('pointermove', onMove)
    document.removeEventListener('pointerup', onUp)
  }

  document.addEventListener('pointermove', onMove)
  document.addEventListener('pointerup', onUp)
})
```

**方案三：使用成熟库**

| 库名              | 特点                       | 生态  | 推荐度     |
| ----------------- | -------------------------- | ----- | ---------- |
| **react-dnd**     | React 官方推荐             | React | ⭐⭐⭐⭐   |
| **dnd-kit**       | 现代化、性能好、无障碍支持 | React | ⭐⭐⭐⭐⭐ |
| **interact.js**   | 框架无关                   | 通用  | ⭐⭐⭐⭐   |
| **Sortable.js**   | 专注列表排序               | 通用  | ⭐⭐⭐     |
| **Vue.Draggable** | Vue 专用                   | Vue   | ⭐⭐⭐⭐   |

**阿里低代码引擎选择**: 自研拖拽系统（基于 Pointer Events）  
**TMagic Editor 选择**: Vue3 + 自研拖拽

### 1.3 组件树管理

#### 数据结构设计

```typescript
interface ComponentNode {
  id: string // 唯一标识
  componentName: string // 组件类型，如 'Button', 'Form'
  props: Record<string, any> // 组件属性
  children?: ComponentNode[] // 子组件
  condition?: boolean | string // 条件渲染
  loop?: any[] | string // 列表渲染

  // 编辑器元信息
  meta?: {
    title: string // 显示名称
    locked: boolean // 是否锁定
    hidden: boolean // 是否隐藏
  }
}

interface PageSchema {
  componentsTree: ComponentNode[] // 组件树
  utils: any[] // 工具函数
  dataSource: DataSource // 数据源配置
  state: Record<string, any> // 页面状态
}
```

#### 核心操作

```typescript
class ComponentTreeManager {
  // 查找节点
  findNode(id: string): ComponentNode | null

  // 插入节点
  insertNode(parentId: string, node: ComponentNode, index?: number): void

  // 删除节点
  removeNode(id: string): void

  // 移动节点
  moveNode(id: string, targetParentId: string, index: number): void

  // 更新节点属性
  updateNodeProps(id: string, props: Partial<ComponentNode['props']>): void

  // 复制节点
  cloneNode(id: string): ComponentNode

  // 撤销/重做
  undo(): void
  redo(): void
}
```

#### 历史记录实现

```typescript
// 使用 Immer 实现不可变数据 + 快照
import { produce } from 'immer'

class History {
  private past: PageSchema[] = []
  private present: PageSchema
  private future: PageSchema[] = []

  push(newState: PageSchema) {
    this.past.push(this.present)
    this.present = newState
    this.future = [] // 清空 redo 栈
  }

  undo(): PageSchema {
    if (this.past.length === 0) return this.present

    this.future.push(this.present)
    this.present = this.past.pop()!
    return this.present
  }

  redo(): PageSchema {
    if (this.future.length === 0) return this.present

    this.past.push(this.present)
    this.present = this.future.pop()!
    return this.present
  }
}
```

---

## 二、Schema 协议设计

### 2.1 为什么需要 Schema？

1. **跨平台**: 同一份 Schema 可以在不同框架中渲染（React/Vue）
2. **可存储**: JSON 格式易于序列化和持久化
3. **可传输**: 通过 API 动态加载页面配置
4. **可分析**: 静态分析、SEO 优化、性能分析
5. **版本管理**: 易于 diff 和版本控制

### 2.2 阿里低代码引擎协议（事实标准）

#### 页面 Schema 结构

```typescript
{
  "componentName": "Page",
  "id": "page-1",
  "props": {
    "title": "用户管理"
  },
  "fileName": "user-management",
  "css": "body { padding: 20px; }",
  "children": [
    {
      "componentName": "Button",
      "id": "btn-1",
      "props": {
        "type": "primary",
        "children": "新增用户"
      },
      "condition": true,
      "loop": false
    }
  ],
  "dataSource": {
    "list": [
      {
        "id": "user-list",
        "type": "fetch",
        "options": {
          "uri": "/api/users",
          "method": "GET"
        },
        "dataHandler": {
          "type": "JSFunction",
          "value": "function(res) { return res.data; }"
        }
      }
    ]
  },
  "state": {
    "currentUser": null,
    "userList": []
  },
  "lifeCycles": {
    "componentDidMount": {
      "type": "JSFunction",
      "value": "function() { this.dataSourceEngine.load('user-list'); }"
    }
  }
}
```

#### 关键字段说明

| 字段            | 说明       | 示例                          |
| --------------- | ---------- | ----------------------------- |
| `componentName` | 组件名称   | `"Button"`, `"Form"`          |
| `props`         | 组件属性   | `{ "type": "primary" }`       |
| `children`      | 子元素     | 数组或字符串                  |
| `condition`     | 条件渲染   | `true` 或 `"state.isVisible"` |
| `loop`          | 列表渲染   | 数组或 `"state.list"`         |
| `dataSource`    | 数据源定义 | API、数据库查询等             |
| `state`         | 页面状态   | 状态变量定义                  |
| `lifeCycles`    | 生命周期   | 钩子函数                      |

### 2.3 百度 amis Schema（配置驱动）

```json
{
  "type": "page",
  "title": "用户管理",
  "body": [
    {
      "type": "crud",
      "api": "/api/users",
      "filter": {
        "title": "筛选",
        "body": [
          {
            "type": "input-text",
            "name": "keywords",
            "label": "关键字",
            "placeholder": "请输入关键字"
          }
        ]
      },
      "columns": [
        {
          "name": "id",
          "label": "ID"
        },
        {
          "name": "name",
          "label": "姓名"
        },
        {
          "name": "email",
          "label": "邮箱"
        }
      ],
      "bulkActions": [
        {
          "label": "批量删除",
          "actionType": "ajax",
          "api": "delete:/api/users/${ids|raw}",
          "confirmText": "确定要删除吗？"
        }
      ]
    }
  ]
}
```

#### amis 的设计特点

- **类型驱动**: 通过 `type` 字段决定渲染什么组件
- **约定优于配置**: 默认行为已定义好，减少配置
- **模板语法**: 支持 `${expression}` 表达式
- **链式 API**: 多个 API 可以串联调用

### 2.4 Schema 协议设计原则

1. **简洁性**: 常用场景配置简单
2. **完备性**: 覆盖所有可能的需求
3. **扩展性**: 容易添加新字段而不破坏兼容性
4. **可读性**: 非开发人员也能理解基本结构
5. **类型安全**: 配合 TypeScript 提供类型定义

### 2.5 表达式系统

#### JSExpression（阿里低代码引擎）

```typescript
interface JSExpression {
  type: 'JSExpression';
  value: string;  // 表达式字符串
  extType?: 'function' | 'variable';
}

// 使用示例
{
  "componentName": "Button",
  "props": {
    "disabled": {
      "type": "JSExpression",
      "value": "state.loading || !state.hasPermission"
    },
    "onClick": {
      "type": "JSExpression",
      "value": "function() { this.setState({ loading: true }); }"
    }
  }
}
```

#### 安全性考虑

```typescript
// ❌ 不安全：直接 eval
const result = eval(expression)

// ✅ 安全：使用沙箱环境
import { Sandbox } from 'lowcode-engine'

const sandbox = new Sandbox({
  state, // 允许访问的状态
  utils, // 允许使用的工具函数
  dataSource, // 数据源
  // 禁止访问 window, document 等全局对象
})

const result = sandbox.execute(expression)
```

---

## 三、组件体系

### 3.1 物料系统架构

```
物料系统
├─ 基础组件 (Primitives)
│  ├─ 布局类: Container, Row, Col, Grid
│  ├─ 表单类: Input, Select, DatePicker, Upload
│  ├─ 展示类: Text, Image, Table, Card
│  └─ 交互类: Button, Tabs, Modal, Drawer
│
├─ 业务组件 (Business Components)
│  ├─ 用户选择器
│  ├─ 部门选择器
│  ├─ 审批流组件
│  └─ 数据看板组件
│
├─ 区块 (Blocks)
│  ├─ 登录表单
│  ├─ 用户列表
│  ├─ 数据统计卡片
│  └─ 导航栏
│
└─ 页面模板 (Templates)
   ├─ 列表页
   ├─ 详情页
   ├─ 表单页
   └─ 大屏页
```

### 3.2 组件元信息（Component Meta）

```typescript
interface ComponentMeta {
  // 基础信息
  componentName: string // 组件名称
  title: string // 显示名称
  description?: string // 组件描述
  icon?: string // 图标
  category?: string // 分类
  tags?: string[] // 标签

  // 组件能力
  isContainer?: boolean // 是否为容器组件
  isModal?: boolean // 是否为弹窗类组件
  nestingRule?: {
    // 嵌套规则
    childWhitelist?: string[] // 允许的子组件
    parentWhitelist?: string[] // 允许的父组件
  }

  // 属性配置
  props: PropMeta[] // 属性配置列表

  // 编辑器配置
  configure: {
    supports: {
      style: boolean // 是否支持样式配置
      events: boolean // 是否支持事件配置
      loop: boolean // 是否支持循环
      condition: boolean // 是否支持条件渲染
    }
  }

  // 代码片段
  snippets?: ComponentSnippet[] // 初始化模板
}

interface PropMeta {
  name: string // 属性名
  title: string // 显示名称
  type: PropType // 属性类型
  setter: SetterConfig // 设置器配置
  defaultValue?: any // 默认值
  description?: string // 描述
  condition?: (target: any) => boolean // 显示条件
}
```

#### 实例：Button 组件元信息

```typescript
const ButtonMeta: ComponentMeta = {
  componentName: 'Button',
  title: '按钮',
  icon: 'icon-button',
  category: '基础组件',
  isContainer: false,
  props: [
    {
      name: 'type',
      title: '按钮类型',
      type: 'string',
      setter: {
        componentName: 'SelectSetter',
        props: {
          options: [
            { label: '主按钮', value: 'primary' },
            { label: '次按钮', value: 'default' },
            { label: '虚线按钮', value: 'dashed' },
            { label: '文字按钮', value: 'text' },
          ],
        },
      },
      defaultValue: 'default',
    },
    {
      name: 'size',
      title: '尺寸',
      type: 'string',
      setter: {
        componentName: 'RadioGroupSetter',
        props: {
          options: [
            { label: '大', value: 'large' },
            { label: '中', value: 'middle' },
            { label: '小', value: 'small' },
          ],
        },
      },
    },
    {
      name: 'loading',
      title: '加载中',
      type: 'boolean',
      setter: {
        componentName: 'BoolSetter',
      },
    },
    {
      name: 'children',
      title: '按钮文字',
      type: 'string',
      setter: {
        componentName: 'StringSetter',
      },
    },
    {
      name: 'onClick',
      title: '点击事件',
      type: 'function',
      setter: {
        componentName: 'FunctionSetter',
      },
    },
  ],
  snippets: [
    {
      title: '主按钮',
      schema: {
        componentName: 'Button',
        props: {
          type: 'primary',
          children: '确认',
        },
      },
    },
  ],
}
```

### 3.3 Setter（设置器）体系

#### 常用设置器

| 设置器           | 用途        | 示例               |
| ---------------- | ----------- | ------------------ |
| StringSetter     | 字符串输入  | 标题、文本内容     |
| NumberSetter     | 数字输入    | 宽度、高度、数量   |
| BoolSetter       | 开关        | 是否显示、是否禁用 |
| SelectSetter     | 下拉选择    | 类型、尺寸选择     |
| RadioGroupSetter | 单选组      | 对齐方式           |
| ColorSetter      | 颜色选择器  | 文字颜色、背景色   |
| JsonSetter       | JSON 编辑器 | 复杂对象配置       |
| ExpressionSetter | 表达式编辑  | 动态绑定           |
| EventSetter      | 事件配置    | onClick, onChange  |
| StyleSetter      | 样式配置    | CSS 样式           |
| DataSourceSetter | 数据源绑定  | 下拉选项、表格数据 |

#### 复合设置器

```typescript
// ObjectSetter: 对象类型配置
{
  name: 'config',
  title: '配置',
  type: 'object',
  setter: {
    componentName: 'ObjectSetter',
    props: {
      config: {
        items: [
          {
            name: 'title',
            title: '标题',
            setter: 'StringSetter',
          },
          {
            name: 'count',
            title: '数量',
            setter: 'NumberSetter',
          },
        ],
      },
    },
  },
}

// ArraySetter: 数组类型配置
{
  name: 'items',
  title: '列表项',
  type: 'array',
  setter: {
    componentName: 'ArraySetter',
    props: {
      itemSetter: {
        componentName: 'ObjectSetter',
        props: {
          config: {
            items: [
              { name: 'label', title: '标签', setter: 'StringSetter' },
              { name: 'value', title: '值', setter: 'StringSetter' },
            ],
          },
        },
      },
    },
  },
}
```

### 3.4 组件渲染引擎

#### Schema to Component 实现

```typescript
// React 渲染器示例
import React from 'react';
import * as AntdComponents from 'antd';

interface RendererProps {
  schema: ComponentNode;
  components?: Record<string, React.ComponentType<any>>;
}

const Renderer: React.FC<RendererProps> = ({ schema, components = {} }) => {
  // 合并内置组件和自定义组件
  const componentMap = {
    ...AntdComponents,
    ...components,
  };

  const renderNode = (node: ComponentNode): React.ReactNode => {
    if (!node) return null;

    // 获取组件
    const Component = componentMap[node.componentName];
    if (!Component) {
      console.warn(`Component ${node.componentName} not found`);
      return null;
    }

    // 处理条件渲染
    if (node.condition === false) {
      return null;
    }

    // 处理循环渲染
    if (node.loop && Array.isArray(node.loop)) {
      return node.loop.map((item, index) =>
        renderNode({
          ...node,
          loop: undefined,
          props: {
            ...node.props,
            key: index,
          },
        })
      );
    }

    // 渲染子节点
    const children = node.children
      ? node.children.map((child) => renderNode(child))
      : node.props?.children;

    return (
      <Component key={node.id} {...node.props}>
        {children}
      </Component>
    );
  };

  return <>{renderNode(schema)}</>;
};

export default Renderer;
```

---

## 四、属性配置面板

### 4.1 动态表单生成

根据组件的 `ComponentMeta` 自动生成属性配置面板。

```typescript
interface SetterPanelProps {
  selectedComponent: ComponentNode;
  componentMeta: ComponentMeta;
  onChange: (props: Record<string, any>) => void;
}

const SetterPanel: React.FC<SetterPanelProps> = ({
  selectedComponent,
  componentMeta,
  onChange,
}) => {
  return (
    <div className="setter-panel">
      <h3>{componentMeta.title} 属性配置</h3>
      {componentMeta.props.map((propMeta) => {
        // 检查显示条件
        if (propMeta.condition && !propMeta.condition(selectedComponent)) {
          return null;
        }

        // 根据 setter 类型渲染不同的配置器
        const SetterComponent = getSetterComponent(propMeta.setter.componentName);

        return (
          <div key={propMeta.name} className="setter-item">
            <label>{propMeta.title}</label>
            <SetterComponent
              value={selectedComponent.props[propMeta.name]}
              onChange={(value) => {
                onChange({
                  ...selectedComponent.props,
                  [propMeta.name]: value,
                });
              }}
              {...propMeta.setter.props}
            />
          </div>
        );
      })}
    </div>
  );
};
```

### 4.2 变量绑定

支持将属性绑定到页面状态或数据源。

```typescript
// 变量绑定设置器
const VariableBindingSetter: React.FC = ({ value, onChange }) => {
  const [mode, setMode] = useState<'static' | 'bind'>('static');

  return (
    <div>
      <Radio.Group value={mode} onChange={(e) => setMode(e.target.value)}>
        <Radio value="static">固定值</Radio>
        <Radio value="bind">变量绑定</Radio>
      </Radio.Group>

      {mode === 'static' ? (
        <Input value={value} onChange={(e) => onChange(e.target.value)} />
      ) : (
        <Select
          value={value}
          onChange={onChange}
          options={[
            { label: 'state.userName', value: 'state.userName' },
            { label: 'state.isLoading', value: 'state.isLoading' },
            { label: 'dataSource.userList', value: 'dataSource.userList' },
          ]}
        />
      )}
    </div>
  );
};
```

---

## 五、数据源与状态管理

### 5.1 数据源类型

```typescript
interface DataSource {
  list: DataSourceItem[]
}

interface DataSourceItem {
  id: string
  type: 'fetch' | 'graphql' | 'database' | 'static'
  options: FetchOptions | GraphQLOptions | DatabaseOptions | any
  dataHandler?: JSFunction // 数据处理函数
  errorHandler?: JSFunction // 错误处理函数
}

// Fetch 数据源
interface FetchOptions {
  uri: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE'
  params?: Record<string, any>
  headers?: Record<string, string>
  body?: any
}

// GraphQL 数据源
interface GraphQLOptions {
  uri: string
  query: string
  variables?: Record<string, any>
}

// 数据库数据源（全栈低代码平台）
interface DatabaseOptions {
  table: string
  action: 'select' | 'insert' | 'update' | 'delete'
  where?: Record<string, any>
  fields?: string[]
  orderBy?: string
  limit?: number
}
```

### 5.2 状态管理方案对比

| 方案                | 适用场景   | 优势                 | 劣势                 |
| ------------------- | ---------- | -------------------- | -------------------- |
| **单一全局状态**    | 简单应用   | 简单直观             | 性能差、难以维护     |
| **分层状态**        | 中等复杂度 | 职责清晰             | 需要设计状态结构     |
| **类 Redux**        | 复杂应用   | 可预测、易调试       | 代码量大、学习成本高 |
| **响应式（Proxy）** | 现代架构   | 自动追踪依赖、性能好 | 需要现代浏览器       |

#### 阿里低代码引擎的状态管理

```typescript
// 状态定义
const pageSchema = {
  state: {
    loading: false,
    userList: [],
    currentPage: 1,
  },

  // 生命周期中加载数据
  lifeCycles: {
    componentDidMount: {
      type: 'JSFunction',
      value: `
        async function() {
          this.setState({ loading: true });
          const data = await this.dataSourceEngine.load('userList');
          this.setState({
            userList: data,
            loading: false
          });
        }
      `,
    },
  },
};

// 组件中使用状态
{
  "componentName": "Table",
  "props": {
    "loading": {
      "type": "JSExpression",
      "value": "state.loading"
    },
    "dataSource": {
      "type": "JSExpression",
      "value": "state.userList"
    }
  }
}
```

### 5.3 数据流设计

```
用户操作 → 事件触发 → 动作执行 → 状态更新 → UI 重新渲染
                      ↓
                  调用数据源 → 后端 API → 返回数据
```

#### 动作系统

```typescript
interface Action {
  type: 'setState' | 'request' | 'navigate' | 'showModal' | 'custom';
  payload: any;
}

// 动作编排示例
{
  "componentName": "Button",
  "props": {
    "onClick": {
      "type": "JSExpression",
      "value": `
        async function() {
          // 1. 设置加载状态
          this.setState({ loading: true });

          // 2. 调用 API
          const result = await this.dataSourceEngine.load('createUser', {
            name: this.state.formData.name,
            email: this.state.formData.email,
          });

          // 3. 显示提示
          if (result.success) {
            this.utils.message.success('创建成功');

            // 4. 跳转页面
            this.utils.history.push('/users');
          } else {
            this.utils.message.error(result.message);
          }

          // 5. 清除加载状态
          this.setState({ loading: false });
        }
      `
    }
  }
}
```

---

## 六、逻辑编排

### 6.1 可视化事件配置

```typescript
interface EventConfig {
  trigger: string // 触发器，如 'onClick', 'onChange'
  actions: ActionConfig[] // 动作列表
}

interface ActionConfig {
  type: 'setState' | 'callDataSource' | 'navigate' | 'showDialog' | 'custom'
  config: any
  condition?: string // 执行条件
  async?: boolean // 是否异步
  successActions?: ActionConfig[] // 成功后的动作
  failActions?: ActionConfig[] // 失败后的动作
}
```

#### 可视化配置 UI

```typescript
const EventConfigPanel = () => {
  return (
    <div>
      <Select placeholder="选择触发事件">
        <Option value="onClick">点击时</Option>
        <Option value="onChange">值改变时</Option>
        <Option value="onLoad">加载时</Option>
      </Select>

      <div className="actions-list">
        {actions.map((action, index) => (
          <ActionItem key={index} action={action}>
            <Select value={action.type}>
              <Option value="setState">设置状态</Option>
              <Option value="callDataSource">调用数据源</Option>
              <Option value="navigate">页面跳转</Option>
              <Option value="showDialog">显示弹窗</Option>
            </Select>

            {/* 根据不同类型显示不同配置表单 */}
            {renderActionConfig(action)}
          </ActionItem>
        ))}
      </div>

      <Button onClick={addAction}>+ 添加动作</Button>
    </div>
  );
};
```

### 6.2 工作流引擎（可选）

流程图式的逻辑编排，适合复杂业务流程。

```typescript
interface WorkflowNode {
  id: string
  type: 'start' | 'end' | 'action' | 'condition' | 'parallel'
  config: any
  next?: string | ConditionalNext
}

interface ConditionalNext {
  conditions: Array<{
    expression: string
    next: string
  }>
  default?: string
}

// 示例：审批流程
const approvalWorkflow: WorkflowNode[] = [
  {
    id: 'start',
    type: 'start',
    next: 'submit',
  },
  {
    id: 'submit',
    type: 'action',
    config: {
      action: 'callDataSource',
      dataSourceId: 'submitApproval',
    },
    next: 'check-level',
  },
  {
    id: 'check-level',
    type: 'condition',
    next: {
      conditions: [
        {
          expression: 'state.amount > 10000',
          next: 'manager-approval',
        },
        {
          expression: 'state.amount > 1000',
          next: 'leader-approval',
        },
      ],
      default: 'auto-approve',
    },
  },
  // ...更多节点
]
```

---

## 七、出码能力

### 7.1 代码生成策略

#### 方案一：直接渲染 Schema（运行时）

```typescript
// 优势：无需构建、动态更新
// 劣势：性能稍差、依赖运行时

import Renderer from '@alilc/lowcode-react-renderer';

function App() {
  return <Renderer schema={pageSchema} />;
}
```

#### 方案二：Schema to Code（编译时）

```typescript
// 优势：性能最优、可脱离平台
// 劣势：需要构建、失去动态性

// Schema
{
  "componentName": "Button",
  "props": {
    "type": "primary",
    "onClick": { "type": "JSExpression", "value": "() => console.log('clicked')" }
  },
  "children": "Click me"
}

// ↓ 生成代码
import { Button } from 'antd';

export default function MyButton() {
  return (
    <Button
      type="primary"
      onClick={() => console.log('clicked')}
    >
      Click me
    </Button>
  );
}
```

### 7.2 代码生成器实现

```typescript
class CodeGenerator {
  generate(schema: PageSchema): string {
    const imports = this.generateImports(schema)
    const stateCode = this.generateState(schema.state)
    const effectsCode = this.generateEffects(schema)
    const renderCode = this.generateRender(schema.componentsTree)

    return `
${imports}

export default function Page() {
  ${stateCode}
  ${effectsCode}
  
  return (
    ${renderCode}
  );
}
    `.trim()
  }

  generateImports(schema: PageSchema): string {
    const components = this.collectComponents(schema)
    return `import React, { useState, useEffect } from 'react';\nimport { ${components.join(', ')} } from 'antd';`
  }

  generateRender(nodes: ComponentNode[]): string {
    return nodes.map(node => this.generateNode(node)).join('\n')
  }

  generateNode(node: ComponentNode): string {
    const props = this.generateProps(node.props)
    const children = node.children
      ? node.children.map(child => this.generateNode(child)).join('\n')
      : node.props?.children || ''

    return `<${node.componentName}${props}>${children}</${node.componentName}>`
  }

  generateProps(props: Record<string, any>): string {
    return Object.entries(props)
      .map(([key, value]) => {
        if (value.type === 'JSExpression') {
          return ` ${key}={${value.value}}`
        }
        return ` ${key}="${value}"`
      })
      .join('')
  }
}
```

### 7.3 代码质量优化

1. **格式化**: 使用 Prettier 格式化生成的代码
2. **Tree Shaking**: 只导入使用到的组件
3. **命名规范**: 自动生成符合规范的变量名
4. **注释生成**: 自动添加必要的注释
5. **类型定义**: 生成 TypeScript 类型

---

## 八、性能优化

### 8.1 编辑器性能优化

1. **虚拟滚动**: 大量组件时只渲染可见区域
2. **增量渲染**: 只更新变化的节点
3. **防抖节流**: 拖拽、输入等高频操作
4. **Web Worker**: 复杂计算移到 Worker
5. **懒加载**: 组件按需加载

### 8.2 渲染器性能优化

1. **React.memo**: 避免不必要的重渲染
2. **动态导入**: Code Splitting
3. **缓存**: 缓存组件实例和计算结果
4. **批量更新**: 合并多次状态更新

```typescript
// 优化前
nodes.forEach(node => {
  updateNode(node) // 每次都触发渲染
})

// 优化后
batch(() => {
  nodes.forEach(node => {
    updateNode(node) // 批量更新，只触发一次渲染
  })
})
```

---

## 九、总结

### 9.1 技术难点

1. **拖拽性能**: 复杂页面的流畅拖拽
2. **Schema 设计**: 平衡简洁性和完备性
3. **表达式安全**: 防止 XSS 攻击
4. **代码质量**: 生成可维护的代码
5. **扩展性**: 支持自定义组件和插件

### 9.2 最佳实践

1. **渐进式设计**: 从简单到复杂，逐步完善
2. **参考标准**: 优先采用阿里低代码引擎协议
3. **开放生态**: 设计插件机制，支持社区贡献
4. **性能优先**: 大型页面也要保持流畅
5. **开发者体验**: 完善的文档和调试工具

### 9.3 学习路径

1. **基础**: 学习 React/Vue、拖拽库、状态管理
2. **阅读源码**: amis、阿里低代码引擎
3. **实践**: 实现简单的拖拽编辑器和渲染器
4. **进阶**: 深入理解 Schema 设计、插件机制
5. **优化**: 性能优化、代码生成质量提升
